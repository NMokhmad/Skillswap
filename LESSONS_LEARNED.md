# Le√ßons tir√©es du projet Skillswap

## Table des mati√®res

1. [SQL et Base de donn√©es](#1-sql-et-base-de-donn√©es)
2. [Migrations](#2-migrations)
3. [S√©curit√©](#3-s√©curit√©)
4. [Tests](#4-tests)
5. [Architecture et bonnes pratiques](#5-architecture-et-bonnes-pratiques)
6. [Ce qui est bien fait](#6-ce-qui-est-bien-fait)
7. [Ce qui doit √™tre am√©lior√©](#7-ce-qui-doit-√™tre-am√©lior√©)
8. [Suivi des corrections](#8-suivi-des-corrections)

---

## 1. SQL et Base de donn√©es

### Ce que tu as bien fait

- **`BEGIN` / `COMMIT`** dans `create_db.sql` : encapsuler la cr√©ation de tables dans une transaction garantit que soit tout est cr√©√©, soit rien ne l'est. Si une erreur survient √† la table 5, les 4 premi√®res ne resteront pas orphelines.

- **`GENERATED BY DEFAULT AS IDENTITY`** au lieu de `SERIAL` : c'est la syntaxe moderne SQL standard (PostgreSQL 10+). `SERIAL` est un raccourci PostgreSQL sp√©cifique, `IDENTITY` est conforme au standard SQL.

- **Contraintes `UNIQUE` composites** : `UNIQUE("reviewer_id", "reviewed_id", "skill_id")` sur `review` et `UNIQUE("follower_id", "followed_id")` sur `user_has_follow` emp√™chent les doublons au niveau de la base, pas juste au niveau de l'application. C'est la bonne approche.

- **`TIMESTAMPTZ`** au lieu de `TIMESTAMP` : stocker le fuseau horaire est essentiel pour une application qui pourrait avoir des utilisateurs dans diff√©rents fuseaux.

- **Cl√©s √©trang√®res d√©clar√©es inline** : `"role_id" INT NOT NULL REFERENCES "role"("id") DEFAULT 1` est clair et lisible.

- ‚úÖ **`CHECK` constraint sur `rate`** : `CHECK (rate >= 1 AND rate <= 5)` emp√™che les donn√©es invalides au niveau de la base, m√™me si quelqu'un contourne l'API. Bien corrig√©.

- ‚úÖ **`ON DELETE CASCADE`** sur toutes les FK : quand un utilisateur est supprim√©, toutes ses reviews, messages, follows, etc. sont automatiquement supprim√©s. Plus besoin de 6 requ√™tes manuelles.

- ‚úÖ **`DEFAULT false` pour `is_read`** dans `message` et **`DEFAULT` pour `is_available`** dans `user` : les valeurs par d√©faut emp√™chent les NULL inattendus.

### Ce qui peut encore √™tre am√©lior√©

- **Pas d'index explicites** : les colonnes fr√©quemment recherch√©es devraient avoir des index. Les colonnes `UNIQUE` cr√©ent automatiquement un index, mais les FK simples (comme `reviewed_id`, `sender_id`) n'en ont pas automatiquement :
  ```sql
  CREATE INDEX idx_review_reviewed_id ON review(reviewed_id);
  CREATE INDEX idx_review_reviewer_id ON review(reviewer_id);
  CREATE INDEX idx_message_sender_id ON message(sender_id);
  CREATE INDEX idx_message_receiver_id ON message(receiver_id);
  CREATE INDEX idx_notification_user_id ON notification(user_id);
  ```
  **Pourquoi c'est important** : sans index, chaque recherche par FK fait un "sequential scan" (lecture de TOUTE la table). Avec 10 000 messages, chercher les messages d'un utilisateur prend 100x plus de temps sans index.

- **`DROP TABLE IF EXISTS` au d√©but** : c'est pratique pour le d√©veloppement mais dangereux si ce script √©tait ex√©cut√© en production. En production, on utilise des migrations (pas des scripts de recr√©ation).

- **Donn√©es de seed invalides** : `seeding_tables.sql` ligne 38 ins√®re un `rate=0` qui viole la contrainte `CHECK (rate >= 1 AND rate <= 5)`. Le seed √©chouera. Il faut corriger cette valeur.

---

## 2. Migrations

### Le√ßon principale : `sequelize.sync({ alter: true })` n'est PAS une migration

Dans `index.js` :
```javascript
// Dev : sync({ alter: true }), Prod : sync()
```

C'est mieux qu'avant (s√©paration dev/prod), mais `sync()` m√™me sans `alter` n'est pas une vraie migration. Voici pourquoi :

| | `sync({ alter: true })` | Vraies migrations |
|---|---|---|
| **Quoi** | Compare les mod√®les JS aux tables et modifie la DB | Scripts SQL versionn√©s ex√©cut√©s un par un |
| **Reproductible** | Non, d√©pend de l'√©tat actuel | Oui, chaque migration a un `up` et un `down` |
| **Perte de donn√©es** | Possible (renommer une colonne = supprimer + cr√©er) | Contr√¥l√© (tu √©cris le ALTER toi-m√™me) |
| **Historique** | Aucun | Chaque changement est trac√© et versionn√© |
| **Production** | JAMAIS | Oui, c'est fait pour √ßa |
| **Rollback** | Impossible | `migrate:undo` |

### Comment √ßa devrait fonctionner

1. **Cr√©er une migration** pour chaque changement de sch√©ma :
   ```bash
   npx sequelize-cli migration:generate --name add-avatar-to-user
   ```

2. **√âcrire le `up` et le `down`** :
   ```javascript
   // up: ce que fait la migration
   await queryInterface.addColumn('user', 'avatar_url', { type: Sequelize.TEXT });

   // down: comment annuler la migration
   await queryInterface.removeColumn('user', 'avatar_url');
   ```

3. **Ex√©cuter** : `npx sequelize-cli db:migrate`

4. **Rollback si probl√®me** : `npx sequelize-cli db:migrate:undo`

### R√®gle d'or

> En d√©veloppement : `sync({ alter: true })` est tol√©rable pour prototyper.
> En staging/production : UNIQUEMENT des migrations versionn√©es.
> Ne JAMAIS utiliser `sync({ force: true })` sauf sur une base jetable.

**Note** : les scripts npm pour les migrations existent d√©j√† dans `package.json` (`migrate`, `migrate:undo`, `migrate:undo:all`, `migrate:status`), mais aucune migration n'a √©t√© cr√©√©e. C'est le moment de commencer √† les utiliser.

---

## 3. S√©curit√©

### Ce qui est bien fait (et pourquoi)

- **Argon2 pour le hachage** : c'est le meilleur choix actuel (vainqueur du Password Hashing Competition 2015). Il est r√©sistant aux attaques GPU contrairement √† bcrypt. Bien jou√©.

- **JWT dans un cookie `httpOnly`** : un cookie `httpOnly` ne peut pas √™tre lu par JavaScript c√¥t√© client. √áa prot√®ge contre le vol de token via XSS. C'est mieux que de stocker le JWT dans `localStorage`.

- **`sameSite: 'Strict'`** : emp√™che l'envoi du cookie lors de requ√™tes cross-origin. Protection contre les attaques CSRF.

- **Protection contre le mass assignment** : dans `profilController.updateProfile`, seuls `firstname`, `lastname`, `email` sont extraits du `req.body` via d√©structuration. M√™me si un attaquant envoie `role_id: 1` dans le body, √ßa sera ignor√©.

- **Double strat√©gie JWT** (`verifyJWT` / `optionalJWT`) : bonne s√©paration entre les routes qui n√©cessitent absolument une authentification et celles qui s'adaptent. Le comportement diff√©rent GET vs POST/PUT/DELETE est bien pens√©.

- ‚úÖ **Helmet CSP correctement configur√©** : les directives CSP sont maintenant bien d√©finies avec les sources externes autoris√©es (FontAwesome, Google Fonts, etc.). C'est une des protections les plus importantes contre XSS.

- ‚úÖ **Sanitisation HTML globale** : le middleware `sanitizeHtml.js` nettoie r√©cursivement `req.body` et `req.query` en supprimant tous les tags HTML. Excellente protection contre le XSS stock√©.

- ‚úÖ **Auth rate limiting am√©lior√©** : pass√© de 100 000 √† 15 tentatives par 15 minutes. C'est raisonnable.

### Ce qui doit √™tre corrig√©

#### [CRITIQUE] Le rate limiting global est encore trop haut

```javascript
// index.js ligne 48
const globalLimiter = rateLimit({
  windowMs: 60 * 1000,
  max: 1000,  // ‚Üê 1000 requ√™tes par minute = ~16 req/seconde
});
```

Le commentaire dit "100 requ√™tes par minute" mais la valeur est 1000. Un humain normal fait 1-2 requ√™tes/seconde. √Ä 1000/min, un bot peut encore scraper massivement le site. Valeur recommand√©e :
```javascript
max: 100  // Largement suffisant pour un humain
```

#### [CRITIQUE] Le cookie `userInfo` n'est toujours pas `httpOnly`

```javascript
// authController.js - R√©p√©t√© dans register ET login
res.cookie('userInfo', JSON.stringify({id, firstname, lastname, email}), {
  httpOnly: false,  // ‚Üê Lisible par JavaScript c√¥t√© client
});
```

Ce cookie contient l'id, le pr√©nom, le nom et l'email de l'utilisateur. Un attaquant qui exploite une faille XSS peut lire ces donn√©es.

**Solution** : le middleware `userInfoCookie.js` utilise d√©j√† `res.locals` ‚Äî il suffit de s'appuyer √† 100% dessus et de supprimer le cookie `userInfo` c√¥t√© client. Les templates EJS acc√®dent √† `user` via `res.locals.user` sans avoir besoin d'un cookie lisible c√¥t√© client.

#### [IMPORTANT] Logout en GET = vuln√©rable au CSRF

```javascript
// router.js ligne 33
router.get('/logout', authController.logout);
```

Un simple `<img src="/logout">` inject√© dans un message ou un avis pourrait d√©connecter un utilisateur sans son consentement. **R√®gle** : toute action qui modifie un √©tat (d√©connexion = suppression de cookie) doit √™tre en POST.

#### [IMPORTANT] Mot de passe minimum trop faible

Le schema Joi accepte un mot de passe de 6 caract√®res minimum. Les recommandations NIST actuelles sont **8 caract√®res minimum**. Avec 6 caract√®res, un brute force offline est r√©aliste.

#### [IMPORTANT] SSL `rejectUnauthorized: false`

```javascript
// database.js
dialectOptions: { ssl: { require: true, rejectUnauthorized: false } }
```

√áa d√©sactive la v√©rification du certificat SSL. Un attaquant qui intercepte la connexion entre l'app et la base de donn√©es (attaque Man-in-the-Middle) ne sera pas d√©tect√©. En production, utiliser `rejectUnauthorized: true` avec le certificat CA du fournisseur.

#### [MINEUR] Timing attack possible au login

```javascript
// authController.js
const user = await User.findOne({ where: { email } });
if (!user) { return res.status(401)... }
const isValid = await argon2.verify(user.password, password);
```

Le temps de r√©ponse diff√®re entre "utilisateur inexistant" (rapide) et "mauvais mot de passe" (lent, car argon2 prend du temps). Un attaquant peut en d√©duire quels emails existent dans la base. Solution : toujours ex√©cuter `argon2.verify()` m√™me si l'utilisateur n'existe pas (avec un hash factice).

---

## 4. Tests

### Ce qui est bien fait

- **Tests cibl√©s sur la s√©curit√©** : les 3 fichiers de tests couvrent les aspects critiques (JWT, autorisation, validation). C'est le bon r√©flexe : tester en priorit√© ce qui prot√®ge l'application.

- **Mocking propre** : les fonctions `mockReq()` et `mockRes()` sont bien con√ßues, r√©utilisables, et simulent fid√®lement le comportement d'Express.

- **Tests des cas limites** : token expir√©, token sign√© avec un mauvais secret, pr√©nom trop court, pr√©nom trop long, email invalide... Les cas limites sont bien couverts.

- **`abortEarly: false`** : tester que Joi retourne TOUTES les erreurs d'un coup (pas juste la premi√®re) est important pour l'UX.

- ‚úÖ **Tests d'autorisation appellent les vrais controllers** : `authorization.test.js` appelle maintenant `profilController.updateProfile`, `profilController.deleteProfile`, `authController.logout`. Plus de logique dupliqu√©e dans les tests. Excellent.

### Ce qui peut √™tre am√©lior√©

#### Pas de tests d'int√©gration

Les tests actuels sont tous des tests unitaires qui ne touchent jamais la base de donn√©es. Il manque des tests qui v√©rifient le cycle complet :
```javascript
// Exemple de test d'int√©gration
test('un utilisateur peut cr√©er un avis', async () => {
  // 1. Cr√©er un utilisateur en base
  // 2. Cr√©er un skill en base
  // 3. Appeler POST /review/:userId
  // 4. V√©rifier que l'avis est bien en base
  // 5. Nettoyer la base
});
```

Pour √ßa, il faut :
- Une base de donn√©es de test s√©par√©e (`skillswap_test`)
- Un setup/teardown qui nettoie entre chaque test
- Supertest pour tester les routes HTTP

#### Couverture insuffisante

Ce qui n'est **pas** test√© :
- `messageController` (envoi, lecture, conversations)
- `followController` (follow/unfollow)
- `reviewController` (cr√©ation d'avis)
- `mainController` (homepage, recherche, onboarding)
- `profilController.deleteProfile` (suppression en cascade)
- Les mod√®les Sequelize et leurs associations
- Les cas d'erreur serveur (que se passe-t-il si la DB est down ?)

#### Structure AAA

Les tests pourraient utiliser le pattern AAA (Arrange, Act, Assert) de mani√®re plus explicite :
```javascript
test('description', () => {
  // Arrange - pr√©parer les donn√©es
  const req = mockReq({...});
  const res = mockRes();

  // Act - ex√©cuter l'action
  verifyJWT(req, res, next);

  // Assert - v√©rifier le r√©sultat
  expect(res.redirectUrl).toBe('/login');
});
```

---

## 5. Architecture et bonnes pratiques

### Ce qui est bien fait

- **S√©paration des responsabilit√©s** : models / controllers / middlewares / schemas / views ‚Äî chaque couche a son r√¥le clair.

- **Router centralis√©** avec sections comment√©es (routes publiques vs prot√©g√©es) : on voit d'un coup d'oeil quelle route n√©cessite quelle authentification.

- **`router.route()` pour grouper les m√©thodes HTTP** :
  ```javascript
  router.route("/user/:id/profil")
    .get(verifyJWT, mainController.renderProfilePage)
    .post(verifyJWT, profilController.updateProfile)
    .delete(verifyJWT, profilController.deleteProfile);
  ```
  C'est plus propre que 3 lignes s√©par√©es.

- **Associations Sequelize bidirectionnelles** : `User.hasMany(Review)` ET `Review.belongsTo(User)` sont toujours d√©clar√©es ensemble. Le fichier `models/index.js` est exemplaire.

- **Helpers r√©utilisables** : `addAverageRating()` √©vite la duplication du calcul de moyenne dans chaque controller.

- **S√©paration dev/prod** dans `index.js` : `sync({ alter: true })` en dev, `sync()` en prod, `trust proxy` uniquement en production. Bonne pratique.

- **Middleware sanitizeHtml** : r√©cursif, global, et bien plac√© dans la cha√Æne de middlewares (avant le router).

### Ce qui doit √™tre am√©lior√©

#### [CRITIQUE] Pas de pagination

Les routes `/talents` et `/skills` chargent TOUS les utilisateurs/skills d'un coup. Avec 10 utilisateurs c'est OK, avec 10 000 √ßa crashera par √©puisement m√©moire. Il faut :
```javascript
const page = parseInt(req.query.page) || 1;
const limit = 20;
const offset = (page - 1) * limit;
const users = await User.findAndCountAll({ limit, offset });
```

**Concept √† apprendre** : pagination offset-based vs cursor-based. L'offset est simple mais a des probl√®mes de performance avec de tr√®s gros offsets. Le cursor utilise un point de rep√®re (ex: `WHERE id > lastId LIMIT 20`) et est plus performant.

#### [IMPORTANT] N+1 query dans la recherche

Dans `mainController.searchPage` (lignes 86-96), une seconde requ√™te recharge tous les skills pour les utilisateurs filtr√©s. C'est un pattern N+1 ‚Äî pour N r√©sultats de recherche, on fait N+1 requ√™tes. Solution : utiliser `include` dans la requ√™te initiale.

#### Incoh√©rence de nommage

```javascript
// M√©lange fran√ßais/anglais
renderloginPage    // ‚Üê 'l' minuscule, devrait √™tre renderLoginPage
renderRegisterPage // ‚Üê correct
profilController   // ‚Üê fran√ßais
reviewController   // ‚Üê anglais
```

**R√®gle** : choisir UNE langue (de pr√©f√©rence l'anglais pour le code) et UN style de nommage, puis s'y tenir partout.

#### Code dupliqu√© pour les cookies

La logique de cr√©ation de cookie JWT est identique dans `register` et `login` :
```javascript
// R√©p√©t√© 2 fois dans authController.js
res.cookie('token', token, { httpOnly: true, secure: ..., sameSite: 'Strict' });
res.cookie('userInfo', JSON.stringify({...}), { httpOnly: false, secure: ..., sameSite: 'Strict' });
```

√áa devrait √™tre un helper :
```javascript
function setAuthCookies(res, user, token) {
  res.cookie('token', token, { httpOnly: true, secure: ..., sameSite: 'Strict' });
  // Id√©alement, supprimer le cookie userInfo et utiliser res.locals
}
```

#### Gestionnaire d'erreurs trop g√©n√©rique

```javascript
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).render('404', { title: 'Erreur serveur', cssFile: '404' });
});
```

Probl√®mes :
- Affiche la page 404 pour une erreur 500 (confusing pour l'utilisateur)
- En d√©veloppement, on veut voir le d√©tail de l'erreur
- Pas de distinction entre les types d'erreurs

Solution : cr√©er une vue `500.ejs` d√©di√©e et afficher le stack en dev :
```javascript
app.use((err, req, res, next) => {
  console.error(err.stack);
  const status = err.status || 500;
  res.status(status).render('error', {
    title: 'Erreur serveur',
    cssFile: 'error',
    message: process.env.NODE_ENV === 'development' ? err.message : 'Une erreur est survenue',
  });
});
```

#### Mod√®le Notification inutilis√©

Le mod√®le `Notification.js` existe avec des associations d√©finies, mais aucun controller ne l'utilise. C'est du code mort. Soit on impl√©mente la fonctionnalit√©, soit on supprime le mod√®le pour ne pas confondre les d√©veloppeurs.

#### `method-override` pour DELETE

L'utilisation de `method-override` avec `?_method=DELETE` dans les formulaires HTML est une solution acceptable pour les formulaires classiques (HTML ne supporte que GET/POST), mais il faut savoir que c'est un pattern legacy. Pour une API moderne, on utiliserait `fetch` avec la m√©thode DELETE directement.

---

## 6. Ce qui est bien fait (r√©sum√©)

| Aspect | D√©tail | Statut |
|--------|--------|--------|
| Hachage mot de passe | Argon2 (meilleur choix actuel) | ‚≠ê Excellent |
| Authentification | JWT dans cookie httpOnly + sameSite Strict | üü¢ Bon |
| Validation | Joi avec schemas d√©di√©s par action | üü¢ Bon |
| Mass assignment | Whitelist par d√©structuration | ‚≠ê Excellent |
| Architecture | MVC clair avec s√©paration des couches | üü¢ Bon |
| Associations Sequelize | Bidirectionnelles, bien nomm√©es avec alias | ‚≠ê Excellent |
| SQL | Transactions, IDENTITY, TIMESTAMPTZ, CHECK, CASCADE | üü¢ Bon |
| Tests | Focalis√©s sur la s√©curit√©, appellent les vrais controllers | üü¢ Bon |
| Middleware JWT | Double strat√©gie (strict / optionnel) | ‚≠ê Excellent |
| CSP Helmet | Correctement configur√© avec whitelist | üü¢ Bon |
| Sanitisation HTML | Middleware global r√©cursif | üü¢ Bon |
| S√©paration dev/prod | sync, trust proxy, rate limiting adapt√©s | üü¢ Bon |

---

## 7. Ce qui doit √™tre am√©lior√© (r√©sum√© prioris√©)

### Priorit√© haute [CRITIQUE]

| # | Probl√®me | Impact | Solution | Statut |
|---|----------|--------|----------|--------|
| 1 | Rate limit global = 1000 | Scraping/brute force possible | Mettre `max: 100` | ‚ùå √Ä corriger |
| 2 | Cookie `userInfo` non httpOnly | Donn√©es user lisibles via XSS | Passer les infos via `res.locals` uniquement | ‚ùå √Ä corriger |
| 3 | Pas de pagination | Crash m√©moire √† l'√©chelle | `findAndCountAll` avec `limit`/`offset` | ‚ùå √Ä corriger |

### Priorit√© moyenne [IMPORTANT]

| # | Probl√®me | Impact | Solution | Statut |
|---|----------|--------|----------|--------|
| 4 | Logout en GET | CSRF via `<img src="/logout">` | Passer en POST + verifyJWT | ‚ùå √Ä corriger |
| 5 | Mot de passe min 6 chars | Brute force offline r√©aliste | Augmenter √† 8 minimum | ‚ùå √Ä corriger |
| 6 | SSL rejectUnauthorized: false | Vuln√©rable au MITM | Utiliser le certificat CA du provider | ‚ùå √Ä corriger |
| 7 | Pas d'index sur les FK | Requ√™tes lentes sur les jointures | `CREATE INDEX` sur les FK fr√©quentes | ‚ùå √Ä corriger |
| 8 | N+1 query dans la recherche | Performance d√©grad√©e | Utiliser `include` dans la requ√™te initiale | ‚ùå √Ä corriger |
| 9 | Pas de tests d'int√©gration | Pas de garantie bout en bout | Supertest + base de test | ‚ùå √Ä corriger |
| 10 | Erreur 500 affiche page 404 | UX confusante | Cr√©er une vraie page erreur 500 | ‚ùå √Ä corriger |

### Priorit√© basse [MINEUR]

| # | Probl√®me | Impact | Solution | Statut |
|---|----------|--------|----------|--------|
| 11 | Nommage incoh√©rent (fr/en) | Lisibilit√© du code | Choisir une langue et s'y tenir | ‚ùå √Ä corriger |
| 12 | Code cookie dupliqu√© | Maintenance plus difficile | Extraire un helper `setAuthCookies` | ‚ùå √Ä corriger |
| 13 | `sync({ alter: true })` en dev | Mauvaise habitude | Utiliser les migrations m√™me en dev | ‚ùå √Ä corriger |
| 14 | Timing attack au login | Fuite d'emails existants | Toujours ex√©cuter argon2.verify | ‚ùå √Ä corriger |
| 15 | Seed data invalide (rate=0) | Seed √©choue | Corriger √† rate >= 1 | ‚ùå √Ä corriger |
| 16 | Notification model inutilis√© | Code mort | Impl√©menter ou supprimer | ‚ùå √Ä corriger |

---

## 8. Suivi des corrections

### Corrections effectu√©es depuis la premi√®re revue ‚úÖ

| Probl√®me original | Correction | Date |
|---|---|---|
| CSP Helmet d√©sactiv√© | Directives CSP correctement configur√©es | F√©vrier 2025 |
| Rate limit auth = 100 000 | R√©duit √† 15 tentatives/15 min | F√©vrier 2025 |
| Pas de CHECK sur rate | `CHECK (rate >= 1 AND rate <= 5)` + validation Sequelize | F√©vrier 2025 |
| Pas de ON DELETE CASCADE | CASCADE sur toutes les FK | F√©vrier 2025 |
| Tests testaient une copie du code | Tests appellent les vrais controllers | F√©vrier 2025 |
| Pas de sanitisation HTML | Middleware sanitizeHtml global et r√©cursif | F√©vrier 2025 |
| Pas de DEFAULT is_read/is_available | DEFAULT ajout√©s dans le SQL | F√©vrier 2025 |

### Progression globale

- **Premi√®re revue** : 15 probl√®mes identifi√©s
- **Probl√®mes corrig√©s** : 7/15 (47%)
- **Nouveaux probl√®mes d√©couverts** : 5 (timing attack, SSL, logout GET, seed invalide, N+1 query)
- **Total restant** : 16 probl√®mes (3 critiques, 7 importants, 6 mineurs)

---

## Conclusion

Ce projet montre une **progression significative** depuis la premi√®re revue. Les corrections effectu√©es touchent les points les plus importants : s√©curit√© (CSP, sanitisation, rate limiting auth), int√©grit√© des donn√©es (CHECK, CASCADE, DEFAULT), et qualit√© des tests (vrais controllers appel√©s).

Les principaux axes d'am√©lioration restants sont :

1. **Finaliser le rate limiting** global (1000 ‚Üí 100)
2. **Supprimer le cookie `userInfo`** c√¥t√© client et utiliser `res.locals`
3. **Ajouter la pagination** avant que la base grossisse
4. **S√©curiser le logout** en POST
5. **Ajouter des index** sur les FK pour la performance

Le r√©flexe de corriger la s√©curit√© en priorit√© est le bon. Continue dans cette direction ‚Äî les probl√®mes de performance (pagination, index, N+1) sont les prochains sur la liste.

**Note de qualit√© globale : üü° Acceptable ‚Üí en bonne voie vers üü¢ Bon**

Pour passer au niveau sup√©rieur :
- Corrige les 3 probl√®mes critiques restants
- Ajoute des tests d'int√©gration
- Impl√©mente les migrations
