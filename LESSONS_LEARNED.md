# Leçons tirées du projet Skillswap

## Table des matières

1. [SQL et Base de données](#1-sql-et-base-de-données)
2. [Migrations](#2-migrations)
3. [Sécurité](#3-sécurité)
4. [Tests](#4-tests)
5. [Architecture et bonnes pratiques](#5-architecture-et-bonnes-pratiques)
6. [Ce qui est bien fait](#6-ce-qui-est-bien-fait)
7. [Ce qui doit être amélioré](#7-ce-qui-doit-être-amélioré)

---

## 1. SQL et Base de données

### Ce que tu as bien fait

- **`BEGIN` / `COMMIT`** dans `create_db.sql` : encapsuler la création de tables dans une transaction garantit que soit tout est créé, soit rien ne l'est. Si une erreur survient à la table 5, les 4 premières ne resteront pas orphelines.

- **`GENERATED BY DEFAULT AS IDENTITY`** au lieu de `SERIAL` : c'est la syntaxe moderne SQL standard (PostgreSQL 10+). `SERIAL` est un raccourci PostgreSQL spécifique, `IDENTITY` est conforme au standard SQL.

- **Contraintes `UNIQUE` composites** : `UNIQUE("reviewer_id", "reviewed_id", "skill_id")` sur `review` et `UNIQUE("follower_id", "followed_id")` sur `user_has_follow` empêchent les doublons au niveau de la base, pas juste au niveau de l'application. C'est la bonne approche.

- **`TIMESTAMPTZ`** au lieu de `TIMESTAMP` : stocker le fuseau horaire est essentiel pour une application qui pourrait avoir des utilisateurs dans différents fuseaux.

- **Clés étrangères déclarées inline** : `"role_id" INT NOT NULL REFERENCES "role"("id") DEFAULT 1` est clair et lisible.

### Ce qui peut être amélioré

- **Pas d'index explicites** : les colonnes fréquemment recherchées devraient avoir des index. Par exemple :
  ```sql
  CREATE INDEX idx_review_reviewed_id ON review(reviewed_id);
  CREATE INDEX idx_message_sender_id ON message(sender_id);
  CREATE INDEX idx_message_receiver_id ON message(receiver_id);
  CREATE INDEX idx_user_email ON "user"(email);  -- déjà couvert par UNIQUE, mais bon à savoir
  ```
  Les colonnes `UNIQUE` créent automatiquement un index, mais les FK simples (comme `reviewed_id`, `sender_id`) n'en ont pas automatiquement.

- **Pas de `CHECK` constraints** : la table `review` accepte n'importe quel entier pour `rate`. Il faudrait :
  ```sql
  "rate" INT NOT NULL CHECK (rate >= 1 AND rate <= 5)
  ```
  La validation Joi côté applicatif ne suffit pas : si quelqu'un contourne l'API, la base doit se protéger elle-même.

- **Pas de `ON DELETE CASCADE`** : quand un utilisateur est supprimé, toutes ses reviews, messages, follows, etc. doivent aussi être supprimés. Actuellement, c'est fait manuellement dans `profilController.deleteProfile` avec 6 requêtes séparées. Avec `ON DELETE CASCADE` sur les FK :
  ```sql
  "reviewer_id" INT NOT NULL REFERENCES "user"("id") ON DELETE CASCADE
  ```
  Une seule instruction `DELETE FROM "user" WHERE id = X` suffirait.

- **`DROP TABLE IF EXISTS` au début** : c'est pratique pour le développement mais dangereux si ce script était exécuté en production. En production, on utilise des migrations (pas des scripts de recréation).

- **Pas de valeur par défaut pour `is_read`** dans `message` :
  ```sql
  "is_read" BOOLEAN DEFAULT false  -- pas juste BOOLEAN sans valeur par défaut
  ```

- **Pas de valeur par défaut pour `is_available`** dans `user` : même problème, devrait être `DEFAULT true` ou `DEFAULT false`.

---

## 2. Migrations

### Leçon principale : `sequelize.sync({ alter: true })` n'est PAS une migration

Dans `index.js` ligne 18 :
```javascript
sequelize.sync({ alter: true })
```

C'est l'erreur la plus courante avec Sequelize. Voici pourquoi c'est problématique :

| | `sync({ alter: true })` | Vraies migrations |
|---|---|---|
| **Quoi** | Compare les modèles JS aux tables et modifie la DB | Scripts SQL versionnés exécutés un par un |
| **Reproductible** | Non, dépend de l'état actuel | Oui, chaque migration a un `up` et un `down` |
| **Perte de données** | Possible (renommer une colonne = supprimer + créer) | Contrôlé (tu écris le ALTER toi-même) |
| **Historique** | Aucun | Chaque changement est tracé et versionné |
| **Production** | JAMAIS | Oui, c'est fait pour ça |
| **Rollback** | Impossible | `migrate:undo` |

### Comment ça devrait fonctionner

1. **Créer une migration** pour chaque changement de schéma :
   ```bash
   npx sequelize-cli migration:generate --name add-avatar-to-user
   ```

2. **Écrire le `up` et le `down`** :
   ```javascript
   // up: ce que fait la migration
   await queryInterface.addColumn('user', 'avatar_url', { type: Sequelize.TEXT });

   // down: comment annuler la migration
   await queryInterface.removeColumn('user', 'avatar_url');
   ```

3. **Exécuter** : `npx sequelize-cli db:migrate`

4. **Rollback si problème** : `npx sequelize-cli db:migrate:undo`

### Règle d'or

> En développement : `sync({ alter: true })` est tolérable pour prototyper.
> En staging/production : UNIQUEMENT des migrations versionnées.
> Ne JAMAIS utiliser `sync({ force: true })` sauf sur une base jetable.

---

## 3. Sécurité

### Ce qui est bien fait (et pourquoi)

- **Argon2 pour le hachage** : c'est le meilleur choix actuel (vainqueur du Password Hashing Competition 2015). Il est résistant aux attaques GPU contrairement à bcrypt. Bien joué.

- **JWT dans un cookie `httpOnly`** : un cookie `httpOnly` ne peut pas être lu par JavaScript côté client. Ça protège contre le vol de token via XSS. C'est mieux que de stocker le JWT dans `localStorage`.

- **`sameSite: 'Strict'`** : empêche l'envoi du cookie lors de requêtes cross-origin. Protection contre les attaques CSRF.

- **Protection contre le mass assignment** : dans `profilController.updateProfile`, seuls `firstname`, `lastname`, `email` sont extraits du `req.body` via déstructuration. Même si un attaquant envoie `role_id: 1` dans le body, ça sera ignoré.

- **Double stratégie JWT** (`verifyJWT` / `optionalJWT`) : bonne séparation entre les routes qui nécessitent absolument une authentification et celles qui s'adaptent.

### Ce qui doit être corrigé

#### Le rate limiting est inutile tel quel

```javascript
// index.js ligne 33 - Le commentaire dit "100 requêtes par minute" mais la valeur est 1 000 000
const globalLimiter = rateLimit({
  windowMs: 60 * 1000,
  max: 1000000,  // ← Un million de requêtes par minute = pas de limite
});

// index.js ligne 42 - Le commentaire dit "10 tentatives par 15 min" mais la valeur est 100 000
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100000,  // ← Cent mille tentatives = pas de limite
});
```

Les commentaires disent une chose, le code fait l'inverse. C'est pire que pas de rate limiting du tout car ça donne une fausse impression de sécurité. Valeurs recommandées :
```javascript
// Global : 100 requêtes/minute (largement suffisant pour un humain)
max: 100

// Auth : 10 tentatives/15 min (protège contre le brute force)
max: 10
```

#### Helmet CSP désactivé

```javascript
app.use(helmet({ contentSecurityPolicy: false }));
```

Le Content-Security-Policy est l'une des protections les plus importantes contre XSS. Le désactiver entièrement parce que FontAwesome est externe est une mauvaise raison. Solution :
```javascript
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "https://kit.fontawesome.com"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://ka-f.fontawesome.com"],
      fontSrc: ["'self'", "https://ka-f.fontawesome.com"],
    }
  }
}));
```

#### Le cookie `userInfo` n'est pas `httpOnly`

```javascript
res.cookie('userInfo', JSON.stringify({...}), {
  httpOnly: false,  // ← Lisible par JavaScript côté client
});
```

Ce cookie contient l'id, le prénom, le nom et l'email de l'utilisateur. Un attaquant qui exploite une faille XSS peut lire ces données. Solutions possibles :
- Rendre ce cookie `httpOnly` et passer les infos user via les templates EJS (via `res.locals`)
- Ou ne stocker que le prénom (pas l'email ni l'id) si c'est juste pour l'affichage

#### Pas de sanitisation HTML

Joi valide le format, mais ne sanitise pas le contenu. Si un utilisateur met `<script>alert('XSS')</script>` dans sa bio ou dans un message, ça sera stocké tel quel en base. Il faut utiliser une librairie comme `sanitize-html` ou `DOMPurify` (côté serveur avec jsdom) pour nettoyer les entrées utilisateur.

---

## 4. Tests

### Ce qui est bien fait

- **Tests ciblés sur la sécurité** : les 3 fichiers de tests couvrent les aspects critiques (JWT, autorisation, validation). C'est le bon réflexe : tester en priorité ce qui protège l'application.

- **Mocking propre** : les fonctions `mockReq()` et `mockRes()` sont bien conçues, réutilisables, et simulent fidèlement le comportement d'Express.

- **Tests des cas limites** : token expiré, token signé avec un mauvais secret, prénom trop court, prénom trop long, email invalide... Les cas limites sont bien couverts.

- **`abortEarly: false`** : tester que Joi retourne TOUTES les erreurs d'un coup (pas juste la première) est important pour l'UX.

### Ce qui peut être amélioré

#### Les tests d'autorisation ne testent pas le vrai code

Dans `authorization.test.js`, la logique est dupliquée dans le test au lieu d'appeler le vrai controller :
```javascript
// ❌ Ce que fait le test : réécrire la logique du controller
const userId = parseInt(req.params.id);
if (req.user.id !== userId) {
  res.status(403).json({ error: '...' });
}

// ✅ Ce que le test devrait faire : appeler le vrai controller
await profilController.updateProfile(req, res, next);
expect(res.statusCode).toBe(403);
```

Si demain quelqu'un retire la vérification d'identité dans le controller, le test passera toujours car il teste sa propre copie du code, pas le vrai code. C'est un faux positif dangereux.

#### Pas de tests d'intégration

Les tests actuels sont tous des tests unitaires qui ne touchent jamais la base de données. Il manque des tests qui vérifient le cycle complet :
```javascript
// Exemple de test d'intégration
test('un utilisateur peut créer un avis', async () => {
  // 1. Créer un utilisateur en base
  // 2. Créer un skill en base
  // 3. Appeler POST /review/:userId
  // 4. Vérifier que l'avis est bien en base
  // 5. Nettoyer la base
});
```

Pour ça, il faut :
- Une base de données de test séparée (`skillswap_test`)
- Un setup/teardown qui nettoie entre chaque test
- Supertest pour tester les routes HTTP

#### Couverture insuffisante

Ce qui n'est **pas** testé :
- `messageController` (envoi, lecture, conversations)
- `followController` (follow/unfollow)
- `reviewController` (création d'avis)
- `mainController` (homepage, recherche, onboarding)
- `profilController.deleteProfile` (suppression en cascade)
- Les modèles Sequelize et leurs associations
- Les cas d'erreur serveur (que se passe-t-il si la DB est down ?)

#### Pas de structure de test standardisée

Les tests pourraient utiliser le pattern AAA (Arrange, Act, Assert) de manière plus explicite :
```javascript
test('description', () => {
  // Arrange - préparer les données
  const req = mockReq({...});
  const res = mockRes();

  // Act - exécuter l'action
  verifyJWT(req, res, next);

  // Assert - vérifier le résultat
  expect(res.redirectUrl).toBe('/login');
});
```

---

## 5. Architecture et bonnes pratiques

### Ce qui est bien fait

- **Séparation des responsabilités** : models / controllers / middlewares / schemas / views — chaque couche a son rôle clair.

- **Router centralisé** avec sections commentées (routes publiques vs protégées) : on voit d'un coup d'oeil quelle route nécessite quelle authentification.

- **`router.route()` pour grouper les méthodes HTTP** :
  ```javascript
  router.route("/user/:id/profil")
    .get(verifyJWT, mainController.renderProfilePage)
    .post(verifyJWT, profilController.updateProfile)
    .delete(verifyJWT, profilController.deleteProfile);
  ```
  C'est plus propre que 3 lignes séparées.

- **Associations Sequelize bidirectionnelles** : `User.hasMany(Review)` ET `Review.belongsTo(User)` sont toujours déclarées ensemble. C'est nécessaire pour que les `include` fonctionnent dans les deux sens.

- **Helpers réutilisables** : `addAverageRating()` évite la duplication du calcul de moyenne dans chaque controller.

### Ce qui doit être amélioré

#### Incohérence de nommage

```javascript
// Mélange français/anglais
renderloginPage    // ← 'l' minuscule, devrait être renderLoginPage
renderRegisterPage // ← correct
profilController   // ← français
reviewController   // ← anglais

// Mélange dans les fichiers CSS
profil_prive.css   // ← snake_case français
myProfil.css       // ← camelCase franglais
help_page.css      // ← snake_case anglais
```

**Règle** : choisir UNE langue (de préférence l'anglais pour le code) et UN style de nommage, puis s'y tenir partout.

#### Code dupliqué pour les cookies

La logique de création de cookie JWT est identique dans `register` et `login` :
```javascript
// Répété 2 fois dans authController.js
res.cookie('token', token, { httpOnly: true, secure: ..., sameSite: 'Strict' });
res.cookie('userInfo', JSON.stringify({...}), { httpOnly: false, secure: ..., sameSite: 'Strict' });
```

Ça devrait être un helper :
```javascript
function setAuthCookies(res, user, token) {
  res.cookie('token', token, { httpOnly: true, secure: ..., sameSite: 'Strict' });
  res.cookie('userInfo', JSON.stringify({...}), { ... });
}
```

#### Suppression manuelle au lieu de CASCADE

`profilController.deleteProfile` fait 6 requêtes `DELETE` manuelles avant de supprimer l'utilisateur. C'est fragile : si on ajoute une nouvelle table liée à `user` et qu'on oublie d'ajouter un `DELETE` ici, on aura une erreur de FK. Avec `ON DELETE CASCADE` dans le SQL, une seule requête suffit.

#### Pas de pagination

Les routes `/talents` et `/skills` chargent TOUS les utilisateurs/skills d'un coup. Avec 10 utilisateurs c'est OK, avec 10 000 ça crashera. Il faut :
```javascript
const page = parseInt(req.query.page) || 1;
const limit = 20;
const offset = (page - 1) * limit;
const users = await User.findAndCountAll({ limit, offset });
```

#### `method-override` pour DELETE

L'utilisation de `method-override` avec `?_method=DELETE` dans les formulaires HTML est une solution acceptable pour les formulaires classiques (HTML ne supporte que GET/POST), mais il faut savoir que c'est un pattern legacy. Pour une API moderne, on utiliserait `fetch` avec la méthode DELETE directement.

#### Gestionnaire d'erreurs trop générique

```javascript
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).render('404', { title: 'Erreur serveur', cssFile: '404' });
});
```

Problèmes :
- Affiche la page 404 pour une erreur 500 (confusing pour l'utilisateur)
- En développement, on veut voir le détail de l'erreur
- Pas de distinction entre les types d'erreurs

---

## 6. Ce qui est bien fait (résumé)

| Aspect | Détail |
|--------|--------|
| Hachage mot de passe | Argon2 (meilleur choix actuel) |
| Authentification | JWT dans cookie httpOnly + sameSite Strict |
| Validation | Joi avec schemas dédiés par action |
| Mass assignment | Whitelist par déstructuration |
| Architecture | MVC clair avec séparation des couches |
| Associations Sequelize | Bidirectionnelles, bien nommées avec alias |
| SQL | Transactions, IDENTITY, TIMESTAMPTZ, contraintes UNIQUE composites |
| Tests | Focalisés sur la sécurité (le plus important) |
| Middleware | Double stratégie JWT (strict / optionnel) |

---

## 7. Ce qui doit être amélioré (résumé priorisé)

### Priorité haute

| # | Problème | Impact | Solution |
|---|----------|--------|----------|
| 1 | Rate limiting = 1M requêtes | Aucune protection brute force | Mettre `max: 100` global et `max: 10` auth |
| 2 | Tests d'autorisation testent une copie du code | Faux positifs possibles | Appeler les vrais controllers dans les tests |
| 3 | Pas de `ON DELETE CASCADE` | 6 requêtes manuelles + risque d'oubli | Ajouter CASCADE dans le SQL / migration |
| 4 | Pas de `CHECK` constraint sur `rate` | Données invalides possibles en base | `CHECK (rate >= 1 AND rate <= 5)` |
| 5 | CSP désactivé | Vulnérable au XSS | Configurer les directives CSP proprement |

### Priorité moyenne

| # | Problème | Impact | Solution |
|---|----------|--------|----------|
| 6 | Pas de pagination | Problème de performance à l'échelle | `findAndCountAll` avec `limit`/`offset` |
| 7 | Cookie `userInfo` non httpOnly | Données user lisibles via XSS | Passer les infos via `res.locals` |
| 8 | Pas d'index sur les FK | Requêtes lentes sur les jointures | `CREATE INDEX` sur les FK fréquentes |
| 9 | Pas de sanitisation HTML | XSS via bio, messages, avis | Utiliser `sanitize-html` |
| 10 | Pas de tests d'intégration | Pas de garantie que le système fonctionne bout en bout | Supertest + base de test |

### Priorité basse

| # | Problème | Impact | Solution |
|---|----------|--------|----------|
| 11 | Nommage incohérent (fr/en) | Lisibilité du code | Choisir une langue et s'y tenir |
| 12 | Code cookie dupliqué | Maintenance plus difficile | Extraire un helper `setAuthCookies` |
| 13 | `sync({ alter: true })` en dev | Pas de problème immédiat mais mauvaise habitude | Utiliser les migrations même en dev |
| 14 | Erreur 500 affiche page 404 | Confusing pour l'utilisateur | Créer une vraie page d'erreur 500 |
| 15 | `is_read` et `is_available` sans DEFAULT | Valeurs NULL au lieu de false | Ajouter `DEFAULT false` |

---

## Conclusion

Ce projet montre de **solides fondamentaux en sécurité** (Argon2, JWT httpOnly, mass assignment protection, validation Joi) et une **bonne architecture MVC**. Les principaux axes d'amélioration sont :

1. **Aligner le code sur les commentaires** (rate limiting)
2. **Faire confiance à la base de données** pour les contraintes (`CASCADE`, `CHECK`, `DEFAULT`)
3. **Tester le vrai code** et pas une copie de la logique
4. **Penser à l'échelle** (pagination, index)
5. **Utiliser les migrations** comme système de vérité pour le schéma

Le réflexe de tester la sécurité en priorité est excellent — c'est une compétence que beaucoup de développeurs seniors n'ont pas. Continue dans cette direction.
